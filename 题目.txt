1.用两个栈的结构来实现队列
2.10000个数，求top10。（用k大小的最小堆来存储）如果数更大，内存一次性存不下怎么办？时间复杂度？
3.一个无序数组求中位数
4.在一个有序数组中，求中位数，如何设计这个函数，形参和返回类型？
5.求最长递增子序列
6.外部排序算法(10G数据排序，内存不够)
	一般利用拓展的归并排序
	思路：将数据进行切分(内存能放得下),对每部分进行排序，最后在归并节点归并每个节点。关键在于归并节点
	归并节点采用堆结构(优先队列)，通过放一部分数据到内存(缓冲区)，新的数据通过网络传输。
7.求海量数据下第k大的数
8.设计一个线程池
9.设计一个内存池
10.有用过gdb调试程序吗？一般都怎么用的
11.熟悉shell吗？如何统计一个文件中某个字符串出现的个数？
12.问算法题，一个大文件中有很多字符串，如何统计出现次数最多的字符串？
13.给一个1~n的无序数组，求最少次数让这个数组变为有序。
14.vector，list，deque的区别
15.vector的大小如何增长？map，set的红黑树和hash_map的性能区别？插入和查找时map和hash_map的区别？
16.树
为什么要引入树呢？一般在学习数据结构时，往往先学习向量和列表，然后是栈与队列。事实上，栈与队列只是在组织数据时额外加入了一些限制，分别是先进后出和先进先出，向量和列表都可以实现这种策略。那么向量和列表又存在什么缺陷呢？一般来讲，我们需要对数据结构做静态操作和动态操作，静态操作就是查找，动态操作就是插入和删除。在C/C++中一般采用数组实现向量，采用链表实现列表。接下来我们看一下它们的静态和动态操作的时间开销。
向量	列表
静态操作(查找)	O(1)	O(n)
动态操作(插入、删除)	O(n)	O(1)
可以看到，已有的数据结构不能很好的平衡静态操作和动态操作的时间开销。
17.二叉排序树、平衡二叉树
一种简单的方法是采用二叉排序树(也叫二叉搜索树，BST，Binary Search Tree)，构造一颗二叉排序树十分简单。一般来讲，大于根节点的放在根节点的右子树上，小于根节点的放在根节点的左子树上(如果等于根节点，则可视情况而定)，如果写程序的话，可以采用递归的方式，而且由于不存在重叠子问题的情况，因此递归的性能已经足够好(不考虑栈溢出的情况)。
二叉排序树在通常情况下可以达到O(lgN)的静态、动态操作的时间复杂度，但是存在一种特殊情况，即输入的数据本身就是有序的，这时二叉排序树退化成向量。
为了消除二叉排序树对于输入敏感的特性，引入平衡二叉树，事实上平衡二叉树应该叫平衡二叉排序树也许更合理。它采用递归的方式定义，这里我就不去查书上的标准定义了，只要保证每个节点左子树和右子树的高度差小于等于1就可以了。
平衡二叉树(也叫AVL树)就比较好用了，可以弥补二叉排序树对输入敏感的缺陷，可以确保静态和动态操作的时间复杂度为O(loN)。
18.B树&B+树
1981年，Bill Gates曾说过这样一段话“640KB is ought to be enough for anybody.”,可能当时intel生产的内存只有640KB，今天看来这句话也许很荒唐，目前好一点的机器都已经达到16GB的内存了，但是事实上这句话仍然有一定的道理。
只要学习过操作系统的人都知道，存储器的访问速度和容量往往成反比(这句话不是很妥当，只要领会意思就好)，最快的当然是CPU上的寄存器，然后是cache(多级cache，不同硬件平台不同)，然后是内存、外部硬盘等等。当两个处在不同层级上的存储器彼此之间交互数据时(例如内存与硬盘之间)，我们称之为I/O，事实上这种I/O操作相当耗时，应该尽可能避免。
B树的出现就是为了解决这个问题，B树由于是多路二叉树，事实上它的高度要远低于二叉平衡树。一般来讲，我们可以认为二叉平衡树每下降一层需要执行一次磁盘I/O操作，以1G数据为例，平均需要30次磁盘I/O才能读取到数据，而B树每下降一层，每个超级结点都会读入多个关键码，需要的磁盘I/O次数小于AVL树，因此B树适用于实现磁盘的读写逻辑。
19.红黑树
对于向量、列表、树和图来说，它们每次的动态操作都会完全遗忘之前的状态，转而到达全新的状态，这种数据结构称为ephemeral structure。另一种数据结构可以记录某一历史时刻的状态，在访问时可以根据版本好+目标数据进行访问，这种数据结构称为persistent structure。事实上，红黑树可以实现这种对历史版本的记录，我也不懂它为什么有这么奇妙的功能，这里就不再深入研究了，因为我觉得研究明白以后我还是会忘，有机会再看。
20.进程和线程区别
	进程是系统进行资源分配和调度的一个独立单位。线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。
21.内存分配方式，内存模型，虚拟内存和物理内存区别
22.select、epoll 的区别，在使用和性能上有什么区别，当只有一个 tcp 客户端时，哪种机制效率更高，有没有看过实现的源码
	select：http://www.cnblogs.com/Anker/archive/2013/08/14/3258674.html
	select缺点：
		单个进程能够监视的文件描述符的数量存在最大限制，通常是1024，当然可以更改数量，但由于select采用轮询的方式扫描文件描述符，文件描述符数量越多，性能越差
		内核/用户空间内存拷贝问题，select需要复制大量的句柄数据结构，产生巨大的开销；
		select返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生了事件；
	poll：http://www.cnblogs.com/Anker/archive/2013/08/15/3261006.html
		poll的机制与select类似，与select在本质上没有多大差别，管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是poll没有最大文件描述符数量的限制。
		采用的是链表来存储描述符。
	epoll：http://www.cnblogs.com/Anker/archive/2013/08/17/3263780.html
		没有最大并发连接的限制，能打开的fd上限远大于1024（1G的内存能监听约10万个端口）
		采用回调的方式，效率提升。只有活跃可用的fd才会调用callback函数，也就是说epoll只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，epoll的效率就会远远高于select和poll。
		内存拷贝。使用mmap()文件映射内存来加速与内核空间的消息传递，减少复制开销。
23.两个进程如何共享 socket、子进程调用 execve 时如何共享 socket
24.说说系统调用的实现原理，参数怎么传
	系统调用其实就是函数调用，只不过调用的是内核态的函数，但是我们知道，用户态是不能随意调用内核态的函数的，所以采用软中断的方式从用户态陷入到内核态。
	在内核中通过软中断0X80。当一个系统调用的参数个数大于5时（因为5个寄存器（eax, ebx, ecx, edx,esi）已经用完了），执行int 0x80指令时仍需将系统调用功能号保存在寄存器eax中，
	所不同的只是全部参数应该依次放在一块连续的内存区域里，同时在寄存器ebx中保存指向该内存区域的指针。系统调用完成之后，返回值扔将保存在寄存器eax中。
	第一，系统调用通过中断实现，需要完成栈切换。第二，使用寄存器传参，这需要额外的保存和恢复的过程。
25.线程同步的4种方式？
	事件
	信号量
	互斥量
	临界区
26.堆和栈的区别？哪个是向高地址的
	一个由C/C++编译的程序占用的内存分为以下几个部分  
  1、栈区（stack）—   由编译器自动分配释放   ，存放函数的参数值，局部变量的值等。其  
  操作方式类似于数据结构中的栈。  
  2、堆区（heap）   —   一般由程序员分配释放，   若程序员不释放，程序结束时可能由OS回  
  收   。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。  
  3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的  
  全局变量和静态变量在一块区域，   未初始化的全局变量和未初始化的静态变量在相邻的另  
  一块区域。   -   程序结束后由系统释放。  
  4、文字常量区   —常量字符串就是放在这里的。   程序结束后由系统释放  
  5、程序代码区—存放函数体的二进制代码。  
  
  栈是向低地址扩展的数据结构，是一块连续的内存区域，栈顶的地址和栈的最大容量是系统预先规定好的，能从栈获得的空间较小。
  堆是向高地址扩展的数据结构，是不连续的内存区域，这是由于系统是由链表在存储空闲内存地址
27.进程死锁的四个条件
答。死锁的原因：系统资源不足，进程运行推进的顺序不合适，资源分配不当等
	死锁的四个必要条件：
	1.互斥条件：每个资源要么已经分配给了一个进程，要么就是可用的
	2.占有和等待条件：已经得到了某个资源的进程可以请求新的资源
	3.不可抢占条件：已经分配出去的资源不能被强制性的抢占，只能自己显式释放
	4.环路等待条件：存在多个进程组成环路，每个进程都在等待下一个进程所占有的资源
28.多线程和多进程的区别，怎么抉择
29.段内存管理
30.Windows下的内存是如何管理的？
	Windows提供了3种方法来进行内存管理：
		虚拟内存，最适合用来管理大型对象或者结构数组；
		内存映射文件，最适合用来管理大型数据流（通常来自文件）以及在单个计算机上运行多个进程之间共享数据；
		内存堆栈，最适合用来管理大量的小对象。
31.Windows消息调度机制是？
	消息队列
32.中断和轮询的特点
	程序轮询：不断询问I/O设备有无处理请求，占据了CPU相当一部分处理时间，因此，程序轮询是一种效率较低的方式，在现代计算机系统中已很少应用。
　　程序中断通常简称中断，是指CPU在正常运行程序的过程中，由于预先安排或发生了各种随机的内部或外部事件，使CPU中断
		正在运行的程序，而转到为响应的服务程序去处理。
　　轮询——效率低，等待时间很长，CPU利用率不高。
　　中断——容易遗漏一些问题，CPU利用率高。
33.临界资源，临界区
	临界资源是一次仅允许一个进程使用的共享资源。各进程采取互斥的方式，实现共享的资源称作临界资源。属于临界资源的硬件有，打印机，磁带机等；
		软件有消息队列，变量，数组，缓冲区等。诸进程间采取互斥方式，实现对这种资源的共享。
	每个进程中访问临界资源的那段代码称为临界区（criticalsection），每次只允许一个进程进入临界区，进入后，不允许其他进程进入。
		不论是硬件临界资源还是软件临界资源，多个进程必须互斥的对它进行访问。多个进程涉及到同一个临界资源的的临界区称为相关临界区。
		使用临界区时，一般不允许其运行时间过长，只要运行在临界区的线程还没有离开，其他所有进入此临界区的线程都会被挂起而进入等待状态，
		并在一定程度上影响程序的运行性能。
34.分段和分页
	页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率；或者说，分页仅仅是由于系统管理的需要，而不是用户的需要。
　　段是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好的满足用户的需要。
　　页的大小固定且由系统确定，把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而一个系统只能有一种大小的页面。段的长度却不固定，决定于用户所编写的程序，通常由编辑程序在对源程序进行编辑时，根据信息的性质来划分。
　　分页的作业地址空间是一维的，即单一的线性空间，程序员只须利用一个记忆符，即可表示一地址。分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。
35.说出你所知道的保持进程同步的方法？
	进程间同步的主要方法有原子操作、信号量机制、自旋锁、管程、会合、分布式系统等。
36.Linux文件属性有哪些
	-rw-r--r--那个是权限符号，总共是- --- --- ---这几个位。
　　第一个短横处是文件类型识别符：-表示普通文件；c表示字符设备（character）；b表示块设备（block）；d表示目录（directory）；
	l表示链接文件（link）；后面第一个三个连续的短横是用户权限位（User），第二个三个连续短横是组权限位（Group），第三个三个连续短横是其他权限位（Other）。
	每个权限位有三个权限，r（读权限），w（写权限），x（执行权限）。如果每个权限位都有权限存在，那么满权限的情况就是：-rwxrwxrwx；权限为空的情况就是- --- --- ---
37.简术OSI的物理层Layer1，链路层Layer2，网络层Layer3的任务
	网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。
　　链路层：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。
　　物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。
38.什么是中断？中断时CPU做什么工作？
	中断是指在计算机执行期间，系统内发生任何非寻常的或非预期的急需处理事件，使得CPU暂时中断当前正在执行的程序而转去执行相应的事件处理程序。
	待处理完毕后又返回原来被中断处继续执行或调度新的进程执行的过程。
39.进程间通信方式：（https://www.ibm.com/developerworks/cn/linux/l-ipc/index.html）
	首先：每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。
	1.管道（Pipe）及有名管道（named pipe）：管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；
		管道只允许具有血缘关系的进程间通信，如父子进程间的通信。
		管道只允许单向通信。
		管道内部保证同步机制，从而保证访问数据的一致性。
		面向字节流。
		管道随进程，进程在管道在，进程消失管道对应的端口也关闭，两个进程都消失管道也消失。
	2.信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）；
	3.报文（Message）队列（消息队列）：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。
	4.共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。
	5.信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。
		信号量本质上是一个计数器，它不以传送数据为主要目的，它主要是用来保护共享资源（信号量也属于临界资源），使得资源在一个时刻只有一个进程独享。
	6.套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。
40.Beautiful Numbers
41.防止死锁
	1.破除互斥等待	->一般无法破除
	2.破除hold and wait	->一次性获取所有资源
	3.破除循环等待	->按顺序获取资源
	4.破除无法剥夺的等待	->加入超时
42.linux的VFS指针和引用的区别，做参数的区别
43.linux目录644权限是待变什么，目录具有可执行权限代表什么
44.awk，grep命令，说出10个常用和好用的
45.编写父子进程程序，要求实现以下功能:	
1）、父进程调用fork创建子进程；
2）、子进程采用SIGALRM设计一个定时器，该定时器的功能是向父进程发送SIGUSR1信号；	
3）、父进程设置SIGUSR1信号处理函数，当接收10次SIGUSR1信号后，杀死子进程，并退出。    
46.利用单生产者和多消费者模型，利用互斥机制实现一个多线程协作拷贝文件的程序。                 
一个线程读文件另外n个线程写，完成1G的文件并行拷贝。    
47.实现网络文件传输的客户端和服务端程序，要求实现以下功能：	
1）、多客户端或客户端的多个线程（至少两个）同时向服务端发文件；	
2）、服务端将收到的数据分别保存下来；
48.TCP流量控制与拥塞控制
TCP流量控制：通过滑动窗口实现（发送方滑动窗口和接收方滑动窗口），发送方窗口大小不大于接收方窗口大小，是的接收方能接受。
TCP拥塞控制：滑动窗口（发送方拥塞窗口和接收方拥塞窗口），算法：慢开始     拥塞避免       快重传        快恢复  
49.三次握手
	客户端状态变化：SYN_SEND->ESTABLISHED
	服务端状态变化：SYN_RECEIVED->ESTABLISHED
50.四次挥手
	客户端状态变化：CLOSE_WAIT1->CLOSE_WAIT2->TIME_WAIT->CLOSED
	服务端状态变化：CLOSE_WAIT->LAST_ACK->CLOSED
51.数据库链接JOIN
	内连接：配合ON使用求两个表的交集
	左连接：配合ON使用求两个表的交集，外加左表剩下的数据
	左连接：配合ON使用求两个表的交集，外加又表剩下的数据