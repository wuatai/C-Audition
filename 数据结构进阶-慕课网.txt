2.2	对数据规模有个概念
	如果想在1s之内解决问题：
	O(n^2)可以处理大约10^4
	O(n)可以处理大约10^8
	O(nlogn)可以处理大约10^7
2.3 简单复杂度分析
	O(1):常数
	void swapTwoInts(int &a,int &b)
	{
		int temp = a;
		a = b;
		b = temp;
	}
	O(n):线性
	int reverse(string &s)
	{
		int n = s.size();
		for(int i = 0;i < n/2;i++)
			swap(s[i],s[n-1-i]);
	}
	O(n^2)
	void selectionSort(int arr[],int n)
	{
		for(int i = 0; i < n; i++)
		{
			int minIndex = i;
			for(int j = i + 1; j < n; j++)
				if(arr[j] < arr[minIndex])
					minIndex = j;
			swap(arr[i],arr[minIndex])
		}
	}
	(n-1)+(n-2)+...+1+0 = n(n-1)/2=1/2*n^2-1/2*n=O(n^2)
	O(logn)
	int binarySearch(int arr[],int n,int target)
	{
		int l = 0; r = n - 1;
		while( l <= r)
		{
			int mid = l + (r - l) / 2;
			if(arr[mid] == target) return mid;
			if(arr[mid] > target) r = mid - 1;
			else l = mid + 1;
		}
		return -1;
	}
	O(nlogn)
	void hello(int n)
	{
		for(int sz = 1;sz < n;sz += sz)
			for(int i = 1;i < n;i++)
				cout << "hello" << endl;
	}
	O(sqrt(n))
	bool isPrime(int n)
	{
		for(int x = 2;x*x <= n;x++)
			if(x%x == 0)
				return false
		return true;
	}
2.5	递归算法的复杂度分析
	如果递归函数中，只进行一次递归调用，递归深度为depth;
	在每个递归函数中，时间复杂度为T;则总体的时间复杂度为O(T*depth)
	
	int sum (int n)
	{
		assert(n >= 0);
		if(n == 0)
			return 0;
		return n + sum(n - 1);
	}
	递归深度:n
	时间复杂度:O(1)
	总体时间复杂度：O(n)
	
	递归中进行多次递归调用，复杂度是调用次数
	int f(int n)
	{
		assert(n >= 0);
		if(n == 0)
			return 1;
		return f(n-1) + f(n - 1);
	}
	办法：画出递归树
	则：1+2+4+8+...
		=2^0+2^1+2^2+...+2^n
		=2^(n-1)-1
		=O(2^n)
2.6 均摊时间复杂度分析：vector的resize()需要均摊到每个push_back()操作

3.1	从二分查找法看如何写出正确的程序
	***数组中的问题其实最常见***
	排序：选择排序；插入排序；归并排序；快速排序
	查找：二分查找
	出具结构：栈；队列；堆
	
	二分查找法
	二分查找法的思想在1946年提出，但是第一个没有bug的二分查找法在1962年出现。
	对于有序的数列，才能使用二分查找法（排序的作用）
	template<typename T>
	int binarySearch(T arr[],int n,T target)
	{
		int l=0,r=n-1;	//要清楚l和r的实际意义，如在[l...r]的范围里寻找target
		while( l <= r ){	//当l == r时，区间依然有元素，所以还应该查找下去
			int mid = (l+r)/2;
			if(arr[mid] == target)
				return mid;
			if(target > arr[mid])
				l = mid + 1;	//target在[mid+1...r]中
			else
				r = mid - 1;	//target在[l...mid-1]中
		}
		return -1；
	}
3.2	改变变量定义，依然可以写出正确的算法
	