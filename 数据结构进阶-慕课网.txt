2.	复杂度分析
2.2	对数据规模有个概念
	如果想在1s之内解决问题：
	O(n^2)可以处理大约10^4
	O(n)可以处理大约10^8
	O(nlogn)可以处理大约10^7
2.3 简单复杂度分析
	O(1):常数
	void swapTwoInts(int &a,int &b)
	{
		int temp = a;
		a = b;
		b = temp;
	}
	O(n):线性
	int reverse(string &s)
	{
		int n = s.size();
		for(int i = 0;i < n/2;i++)
			swap(s[i],s[n-1-i]);
	}
	O(n^2)
	void selectionSort(int arr[],int n)
	{
		for(int i = 0; i < n; i++)
		{
			int minIndex = i;
			for(int j = i + 1; j < n; j++)
				if(arr[j] < arr[minIndex])
					minIndex = j;
			swap(arr[i],arr[minIndex])
		}
	}
	(n-1)+(n-2)+...+1+0 = n(n-1)/2=1/2*n^2-1/2*n=O(n^2)
	O(logn)
	int binarySearch(int arr[],int n,int target)
	{
		int l = 0; r = n - 1;
		while( l <= r)
		{
			int mid = l + (r - l) / 2;
			if(arr[mid] == target) return mid;
			if(arr[mid] > target) r = mid - 1;
			else l = mid + 1;
		}
		return -1;
	}
	O(nlogn)
	void hello(int n)
	{
		for(int sz = 1;sz < n;sz += sz)
			for(int i = 1;i < n;i++)
				cout << "hello" << endl;
	}
	O(sqrt(n))
	bool isPrime(int n)
	{
		for(int x = 2;x*x <= n;x++)
			if(x%x == 0)
				return false
		return true;
	}
2.5	递归算法的复杂度分析
	如果递归函数中，只进行一次递归调用，递归深度为depth;
	在每个递归函数中，时间复杂度为T;则总体的时间复杂度为O(T*depth)
	
	int sum (int n)
	{
		assert(n >= 0);
		if(n == 0)
			return 0;
		return n + sum(n - 1);
	}
	递归深度:n
	时间复杂度:O(1)
	总体时间复杂度：O(n)
	
	递归中进行多次递归调用，复杂度是调用次数
	int f(int n)
	{
		assert(n >= 0);
		if(n == 0)
			return 1;
		return f(n-1) + f(n - 1);
	}
	办法：画出递归树
	则：1+2+4+8+...
		=2^0+2^1+2^2+...+2^n
		=2^(n-1)-1
		=O(2^n)
2.6 均摊时间复杂度分析：vector的resize()需要均摊到每个push_back()操作
3.	数组中的问题其实很常见
3.1	从二分查找法看如何写出正确的程序
	***数组中的问题其实最常见***
	排序：选择排序；插入排序；归并排序；快速排序
	查找：二分查找
	出具结构：栈；队列；堆
	
	二分查找法
	二分查找法的思想在1946年提出，但是第一个没有bug的二分查找法在1962年出现。
	对于有序的数列，才能使用二分查找法（排序的作用）
	template<typename T>
	int binarySearch(T arr[],int n,T target)
	{
		int l=0,r=n-1;	//要清楚l和r的实际意义，如在[l...r]的范围里寻找target
		while( l <= r ){	//当l == r时，区间依然有元素，所以还应该查找下去
			int mid = (l+r)/2;	//整形溢出bug
			int mid = l + (r-l)/2;
			if(arr[mid] == target)
				return mid;
			if(target > arr[mid])
				l = mid + 1;	//target在[mid+1...r]中
			else
				r = mid - 1;	//target在[l...mid-1]中
		}
		return -1；
	}
3.2	改变变量定义，依然可以写出正确的算法
	一定要清楚变量代表什么意义。
	1.明确变量的含义
	2.循环不变量
	3.小数据量调试
	4.大数据量测试
3.3	在leetcode上解决第一个问题Movw Zeros
	给定一个数组nums，写一个函数，将数组中所有的0挪到数组的尾部，而维持其他所有非0元素的相对位置。
	举例：nums=[0,1,0,3,12]，函数运行后结果为[1,3,12,0,0]
	思路1：把非0保存出来，填在nums左端，后端补0
	void moveZeros(vector<int>& nums)
	{
		时间复杂度O(n)	空间复杂度O(n)
		vector<int> nonZeroElements;
		for(int i = 0;i < nums.size();i++)
			if(nums[i])
				nonZeroElements.push_back(num[i]);
		for(int i = 0;i < nonZeroElements.size();i++)
			nums[i] = nonZeroElements[i];
		for(int i = nonZeroElements.size();i<nums.size();i++)
			nums[i] = 0;
	}
	思路2:2个指针，原地
	void moveZeros(vector<int>& nums)
	{
		int k = 0;	//nums中，[0...k)的元素均为非0元素
		//遍历到第i个元素后，保证[0,...k)中所有非0元素都按照顺序排列在[0...k)中
		for(int i = 0;i < nums.size();i++)
			if(nums[i])
				nums[k++] = nums[i];
		//将nums剩余位置放置为0
		for(int i = k;i < nums.size();i++)
			nums[i] = 0;
	}
	思路3：不是赋值，用交换可以避免对后序填0
	void moveZeros(vector<int>& nums)
	{
		int k = 0;	//nums中，[0...k)的元素均为非0元素
		//遍历到第i个元素后，保证[0,...i]中所有非0元素都按照顺序排列在[0...k)中,同时，[k...i]为0
		for(int i = 0;i < nums.size();i++)
			if(nums[i])
				if( i != k)
					swap(nums[k++] = nums[i]);
				else
					k++;
	}
	
	问题2：Remove Element
	给定一个数组nums和一个数值val，将数组中所有等于val的元素删除，并返回剩余元素个数。
	如nums=[3,2,2,3],val=3;返回2，且nums中前两个元素为2
	--如何定义删除？从数组中去除？还是放在数组尾部？
	--剩余元素的排列是否要包拯元游的相对顺序？
	--是否有空间复杂度的要求？O(1)
	问题3:Remove Duplicated from Sorted Array
	给定一个有序数组，对数组中的元素去重，是的原数组的每个元素只有一个。返回去重后数组的长度值
	如nums=[1,1,2],结果颖返回2，且nums的前两个元素为[1,2]
	--如何定义删除？从数组中去除？还是放在数组尾部？
	--剩余元素的排列是否要包拯元游的相对顺序？
	--是否有空间复杂度的要求？O(1)
	问题3:Remove Duplicated from Sorted Array II
	给定一个有序数组，对数组中的元素去重，是的原数组的每个元素只有一个。返回去重后数组的长度值
	如nums=[1,1,1,2,2,3],结果颖返回5，且nums的前两个元素为[1,1,2,2,3]
	--如何定义删除？从数组中去除？还是放在数组尾部？
	--剩余元素的排列是否要包拯元游的相对顺序？
	--是否有空间复杂度的要求？O(1)
3.5 三路快排partition思路的应用Sort Color
	基础算法思路的应用
	Sort Colors
	给定一个有n个元素的数组，数组中元素的取值只有0,1,2三种可能。为这个数组排序。
	-可以使用任意一种排序算法
	-没有使用上题目中给出的特殊条件
	计数排序：分别统计0,1,2的元素个数，然后放回原有数组
	void sortColors(vector<int>& nums)
	{
		//时间复杂度:O(n)
		//空间复杂度:O(k),k=3,即O(1)
		int count[3] = {0};
		for(int i = 0;i < nums.size();i++)
		{
			assert(nums[i] >= 0 && nums[i] <= 2);
			count[nums[i]]++;
		}
		int index = 0;
		for(int i = 0; i < count[0]; i++)
			nums[index++] = 0;
		for(int i = 0; i < count[1]; i++)
			nums[index++] = 1;
		for(int i = 0; i < count[2]; i++)
			nums[index++] = 2;
	}
	三路快排思想
	void sortColors(vector<int>& nums)
	{
		//只遍历了数组一变
		int zero = -1;	//nums[0...zero] = 0,所以zero = -1******注意
		int two = nums.size();		//nums[two...n-1] = 2,所以two = nums.size()******注意
		for(int i = 0; i < two; )
		{
			if(nums[i] == 1)
				i++;
			else if(nums[i] == 2)
				swap(nums[i],nums[--two]);
			else
			{
				assert(nums[i] == 0);
				swap(nums[++zero],nums[i++]);
			}
		}
	}
	问题：Merge Sorted Array
	给定两个有序整形数组nums1,nums2，将nums2的元素归并到num1中
	问题：Kth Largest Element in an Array
	在一个整数序列中寻找第k大的元素
	--如给定数组[3,2,1,5,6,4],k=2，结果为5
	利用快排partition中，将pivot放置在了其正确的位置上的性质
3.6	对撞指针Two Sum II
	给定一个有序整形数组和一个整数target，在其中寻找两个元素，使得其和为target。返回两个数的索引
	--如numbers=[2,7,11,15],target=9
	--返回数字2,7的索引1,2(索引从1开始计算)
	要跟面试官确认
	--如果没有解怎样？保证有解
	--如果有多个解怎样？返回任意解
	1.最直接的思考：暴力解法。双层遍历，O(n^2)
	暴力解法没有充分利用源数组的性质---有序
	2.看到有序，首先想到二分搜索
	O(nlogn)二分解法
	3.对撞指针法:时间复杂度O(n)，空间复杂度O(1)
	vector<int> twoSum(vector<int>& numbers, int target)
	{
		assert(numbers.size() >= 2);
		int l = 0,r = numbers.size() - 1;
		while(l < r)
		{
			if(numbers[l] + numbers[r] == target)
			{
				int res[2] = {l+1,r+1};
				return vector<int>(res,res+2);
			}
			else if(numbers[l] + numbers[r] < target)
				l++;
			else
				r--;
		}
		throw invalid_argument("The input has no solution.");
	}
	问题2：Valid Palindrome
	给定一个字符串，只看其中的数字和字母，忽略大小写，判断这个字符串是否为回文串？
	"A man,a plan,a canal;Panama"	是回文串
	对于字符串要注意以下几个问题：
	--空字符串如何看
	--字符的定义
	--大小写问题
	问题3：Reverse Vowels of a String
	给定一个字符串，将改字符串中的元音字母翻转
	--如：给出"hello"，返回"holle"
	--如：给出"leetcode"，返回"leotcede"
	--元音不包含y
	问题4:Container With Most Water
	给出一个非负整数a1,a2,a3,...,an;每一个整数表示一个竖立在坐标轴x位置的一堵高度为ai的
	“墙”，选择两堵墙，和x轴构成的容器可以容纳最多的水。
3.7 滑动窗口Minimun Size Subarray Sum
	双索引技术Two Pointer
	问题1：Minimun Size Subarray Sum
	给定一个整形数组和一个数字s，找到数组中最短的一个连续子数组，使得连续子数组和sum>=s，返回
	这个最短的连续子数组的返回值
	--如，给定数组[2,3,1,2,4,3],s=7
	--答案为[4,3]，返回2
	确认：
	--什么叫子数组
	--如果没有解怎么办？返回0
	--多个解怎么返回？
	思路1：暴力解：遍历所有的连续子数组[i,j],计算其和sum,验证sum>=s,时间复杂度O(n^3)
	思路2：滑动窗口
	int minSubArrayLen(int s, vector<int>& nums)
	{
		时间复杂度:O(n)
		空间复杂度:O(1)
		int l=0 , r=-1;	//nums[l...r]为我们的滑动窗口
		int sum = 0;
		int res = nums.size() + 1;
		while( l < nums.size() )
		{
			if( r+1 < nums.size() && sum < s )
				sum += nums[++r];
			else 
				sum -= nums[l++];
			if(sum >= s)
				res = min(res,r-l+1);
		}
		if (res == nums.size() + 1)
			return 0;
		return res;
	}
3.8	在滑动窗口中做记录
	问题1：Longest Substring Without Repeating Characters
	在一个字符串中寻找没有重复字母的最长子串
	--如"abcabcbb"，则结果为"abc"
	--如"bbbbb"，则结果为"b"
	--如"pwwkew"，则结果为"wke"
	注意：
	--字符集？只有字幕？数字+字母？ASCII？
	--大小写是否敏感
	int lengthOfLongestSubstring(string s)
	{
		int freq[256] = {0};
		int l = 0; r = -1;	//滑动窗口为s[l...r]
		int res = 0;
		while( l < s.size() )
		{
			if( r+1 < s.size() && freq[s[r+1]] == 0)
				freq[s[++r]]++;
			else
				freq[s[l++]]--;
			res = max(res , r-l+1);
		}
		return res;
	}
	问题2：Find All Anagrams in a String
	问题3：Minimum Window Substring

四、查找问题
	两类查找问题
	查找有无
	--元素'a'是否存在?set;集合
	查找对应关系(键值对应)
	--元素'a'出现了几次？map;字典
	set和map
	通常语言的标准库中都内置set和map
	--容器类
	--屏蔽实现细节
	--了解语言中标准库里常见容器类的使用
	常见操作：
	--insert
	--find
	--erase
	--change(map)
4.	查找表的相关问题
4.1 set的使用
	问题1：Intersection of Two Arrays
	给定两个数组nums,求两个数组的公共元素。
	--如nums1 = [1,2,2,1],nums2 = [2,2]
	--结果为[2]
	--结果中每个元素只能出现一次
	--出现的顺序可以是任意的
	vector<int> intersection(vector<int>& nums1, vector<int>& nums2)
	{
		set<int> record(nums1.begin(), nums1.end());
		set<int> resultSet;
		for(int i = 0;i < nums2.size(); i++)
			if(record.find(nums2[i]) != record.end())
				resultSet.insert(nums2[i]);
		return vector<int>(resultSet.begin(),resultSet.end());
	}
4.2	map的使用
	问题1：Intersection of Two Arrays II
	给定两个数组nums，求两个数组的交集.
	--如nums1 = [1,2,2,1],nums2 = [2,2]
	--结果为[2,2]
	--出现的顺序可以是任意的
	vector<int> intersection(vector<int>& nums1, vector<int>& nums2)
	{
		map<int,int> record;
		for(int i = 0; i < nums1.size(); i++)
			record[nums1[i]]++;
		
		vector<int> resultVector;
		for(int i = 0;i < nums2.size(); i++)
			if(record.find(nums2[i]) != record.end() && record[nums2[i]] > 0)
			{
				resultVector.push_back(nums2[i]);
				record[nums2[i]]--;
			}
		result resultVector;
	}
4.3 set和map不同底层实现的区别
	解决查找问题的一个很好的数据结构：hash表
	哈希表的缺点是失去了数据的顺序性
	map和set的底层实现为平衡二叉树
	unordered_map和unoedered_set的底层实现为哈希表
	问题1：Valid Anagram
	问题2：Happy Number
	问题3：Word Pattern
	问题4：Isomorphic Strings
	问题5：Sort Characters By Frequency
4.4	使用查找表的经典问题Two Sum
	问题1：Two Sum
	给出一个整形数组。返回这个数组中的两个数字的索引值i和j，使得nums[i]+nums[j]等于一个给定的target值。
	两个索引不能相等。
	--如nums = [2,7,11,15],target = 9
	--返回[0,1]
	考虑：
	--索引从0开始计算还是从1开始计算？
	--没有解怎么办？
	--有多个解怎么办？保证有唯一解。
	思路1：暴力解法O(n^2)
	思路2：排序后，使用双索引对撞O(nlogn)+O(n)=O(nlogn)
	思路3：查找表（这是个查找问题）。将所有元素放入查找表，之后对于每一个元素a，查找target-a是否存在。
	vector<int> twoSum(vector<int>& nums, int target)
	{
		//时间复杂度:O(n)
		//空间复杂度:O(n)
		unorder_map<int,int> record;
		for(int i = 0; i < nums.size(); i++)
		{
			int complement = target - nums[i];
			if(record.find(complement) != record.end())
			{
				int res[2] = {i,record[complement]}
				return vector<int>(res,res+2);
			}
			record[nums[i]] = i;
		}
		throw invalid_argument("the input has no solution");
	}
	问题2：3Sum
	给出一个整形数组，寻找其中的所有不同的三元组(a,b,c)，使得a+b+c=0.如nums=[-1,0,1,2,-1,-4]，结果为[[-1,0,1],[-1,-1,2]]
	问题3：4Sum
	给出一个整形数组，寻找其中的所有不同的四元组(a,b,c,d)，使得a+b+c+d=0.
	问题4：3Sum Closest
	给出一个整形数组，寻找其中的所有不同的三元组(a,b,c)，使得a+b+c的值最接近另一个给定的数字target
	--如nums = [-1,2,1,-4],target = 1
4.5	灵活选择键值4Sum II
	给出四个整形数组A,B,C,D,寻找有多少个i,j,k,l的组合，使得A[i]+B[j]+C[k]+D[l]==0.其中，A,B,C,D中均含有相同的元素
	个数N，且0<=N<=500.
	思路1：暴力解发:O(n^4)
	思路2：将D中的元素放入查找表：O(n^3)
	思路3：将C+D的每一种可能放入查找表：O(n^2)
	int fourSumCount(vector<int>& A,vector<int>& B,vector<int>& C,vector<int>& D)
	{
		//时间复杂度O(n^2)
		//空间复杂度O(n^2)
		assert(A.size() == B.size() && B.size() == C.size() && C.size() == D.size());
		unordered_map<int,int> record;
		for(int i = 0; i < C.size(); i++)
			for(int j = 0; j < D.size();j++)
				record[C[i]+D[j]]++;
		int res = 0;
		for(int i = 0;i < A.size(); i++)
			for(int j = 0; j < B.size(); j++)
				if(record.find(0-A[i]-B[j]) != record.end())
					res += record[0-A[i]-B[j]];
		return res;
	}
	问题2：Group Anagrams
4.6 灵活选择键值Number of Boomerangs
	给出一个平面上的n个点，寻找存在多少个由这些点构成的三元组(i,j,k)，使得i,j两点的距离等于i,k两点的距离。
	其中n最多为500，且所有的点坐标的范围在[-10000,10000]之间。
	--如[[0,0],[1,0],[2,0]]，则结果为2
	--两个结果为[[1,0],[0,0],[2,0]]和[[1,0],[2,0],[0,0]]
	思路1：暴力解法:O(n^3)
	思路2：map中存距i点的所有距离及点数
	int numberOfBoomerangs(vector<pair<int,int>>& points)
	{
		//时间复杂度O(n^2)
		//空间复杂度O(n)
		int res = 0;
		for(int i = 0; i < points.size(); i++)
		{
			unordered_map<int,int> record;
			for(int j = 0;j < points.size();j++)
				if(j != i)
					record[dis(points[i],points[j])]++;
			for(unordered_map<int,int>::iterator iter = record.begin();iter != record.end(); iter++)
			{
				if(iter->second >= 2)
					res += (iter->second)*(iter->second-1);
			}
		}
		return res;
	}
	int dis(const pair<int,int>& pa,const pair<int,int>& pb)
	{
		return (pa.first-pb.first)*(pa.first-pb.first)+(pa.second-pb.second)*(pa.second-pb.second);
	}
	问题2：Max Points on a Line
4.7 查找表和滑动窗口
	问题1：Contains Dumplicate II
	给出一个整形数组nums和一个整数k，是否存在索引i和j，使得nums[i]==nums[j]且i和j之间的差不超过k
	思路1：暴力解法:O(n^2)
	思路2：滑动窗口
	bool containsNearbyDuplicate(vector<int>& nums, int k)
	{
		//时间复杂度:O(n)
		//空间复杂度:O(k)
		unordered_set<int> record;
		for(int i = 0;i < nums.size();i++)
		{
			if(record.find(nums[i]) != record.end())
				return true;
			record.insert(nums[i]);
			//保持record中最多有k个元素
			if(record.size() == k + 1)
				record.erase(nums[i-k]);
		}
		return false;
	}
	问题2:Contains Duplicate
4.8	二分搜索树底层实现的顺序性Contain Duplicate III
	给出一个整形数组nums，是否存在索引i和j，使得nums[i]和nums[j]之间的差别不超过给定的整数t,
	且i和j之间的差别不超过给定的整数k
	思路1：滑动窗口，在l+1...l+k之间，寻找fabs(v-x)<=t的元素，其中v为第l+k+1的元素
	bool containsNearbyAlmostDuplicate(vector<int>& nums, int k,int t)
	{
		//时间复杂度:O(n)
		//空间复杂度:O(k)
		set<int> record;
		for(int i = 0;i < nums.size();i++)
		{
			if(record.lower_bound(nums[i]-t) != record.end() && *record.lower_bound(nums[i]-t) <= nums[i]+t)
				return true;
			record.insert(nums[i]);
			//保持record中最多有k个元素
			if(record.size() == k + 1)
				record.erase(nums[i-k]);
		}
		return false;
	}
5.	在链表中穿针引线
5.1 链表
	问题1：在节点间穿针引线Reverse Linked List
	需要三个指针(pre,cur,next)
	struct ListNode{
		int val;
		ListNode *next;
		ListNode(int x):val(x),next(NULL){}
	};
	ListNode* reverseList(ListNode* head)
	{
		时间复杂度O(n)
		空间复杂度O(1)
		ListNode* pre = NULL;
		ListNode* cur = head;
		while(cur != NULL)
		{
			ListNode* next = cur->next;
			cur->next = pre;
			pre = cur;
			cur = next;
		}
		return pre;
	}
	问题2：Reverse Linked List II
	翻转一个链表从m到n的元素
	如对于链表1->2->3->4->5->NULL,m=2,n=4
	则返回链表1->4->3->2->5->NULL
	--m和n超过链表范围怎么办？
	--m>n怎么办？
5.2 测试你的链表程序
	ListNode* createLinkedList(int arr[],int n)
	{
		if(n == 0)
			return NULL;
		ListNode* head = new ListNode(arr[0]);
		
		ListNode* curNode = head;
		for(int i = 1;i < n; i++)
		{
			curNode->next = new ListNode(arr[i]);
			curNode = curNode->next;
		}
		return head;
	}
	void deleteLinkedList(ListNode* head)
	{
		ListNode* curNode = head;
		while(curNode != NULL)
		{
			ListNode* delNode = curNode;
			curNode = curNode->next;
			delete delNode;
		}
		return;
	}
	void printLinkedList(ListNode* head)
	{
		ListNode* curNode = head;
		while(curNode != NULL)
		{
			cout << curNode->val << " -> ";
			curNode = curNode->next;
		}
		cout << "NULL" << endl;
	}
	问题2.Remove Duplicates from Sorted List
	问题3.Partition List
	问题4.Odd Even Linked List
	问题5.Add Two Numbers
	问题6.Add Two Numbers II
5.3 设立链表的虚拟头结点
	问题1:Remove Linked List Elements
	在链表中删除值为val的所有节点
	--如1->2->6->3->4->5->6->NULL
	--返回1->2->3->4->5->NULL
	ListNode* removeElements(ListNode* head,int val)
	{
		if(head == NULL)
			return head;
		while(head != NULL && head->val == val){
			ListNode* delNode = head;
			head = delNode->next;
			delete delNode;
		}
		if(head == NULL)
			return NULL;
		ListNode* cur = head;
		while(cur->next != NULL)
		{
			if(cur->next->val == val)
			{
				ListNode* delNode = cur-next;
				cur->next = delNode->next;
				delete delNode;
			}
			else
				cur = cur->next;
		}
		return head;
	}
	虚拟头结点：
	ListNode* removeElements(ListNode* head,int val)
	{
		ListNode* dummyHead = new ListNode(0);
		dummyHead->next = head;
		
		ListNode* cur = dummyHead;
		while(cur->next != NULL)
		{
			if(cur->next->val == val)
			{
				ListNode* delNode = cur-next;
				cur->next = delNode->next;
				delete delNode;
			}
			else
				cur = cur->next;
		}
		ListNode* retNode = dummyHead->next;
		delete dummyHead;
		return retNode;
	}
	问题2：Remove Dumplicates from Sorted List II
	问题3：Merge Two Sorted Lists
5.4 复杂的穿针引线
	问题1：Swap Nodes in Pairs
	给定一个链表，对于每两个相邻的节点，交换其位置。
	-如：链表为1->2->3->4->NULL
	-返回:2->1->4->3->NULL
	-只能对节点进行操作，不能修改节点的值
	ListNode* swapPairs(ListNode* head)
	{
		ListNode* dummyHead = new ListNode(0);
		dummyHead->next = head;
		
		ListNode* p = dummyHead;
		while(p->next && p->next->next)
		{
			ListNode* node1 = p->next;
			ListNode* node2 = node1->next;
			ListNode* next = node->next;
			
			node2->next = node1;
			node1->next = next;
			p->next = node2;
		}
		ListNode* retNode = dummyHead->next;
		delete dummyHead;
		return retNode;
	}
	问题2：Reverse Nodes in k-Group
	问题3：Insertion Sort List
	问题4；Sort List,写一个排序算法，用O(nlogn)的时间复杂度为一个链表进行排序（归并排序）
5.5	不仅仅是穿针引线
	问题1：Delete Node in a Linked List
	给定链表中的一个节点，删除该节点
	void deleteNode(ListNode* node)
	{
		if(node == NULL)
			return;
		if(node->next == NULL)
		{
			delete node;
			node = NULL;
		}
		node->val = node->next->val;
		ListNode* delNode = node->next;
		node->next = delNode->next;
		delete delNode;
		return;
	}
5.6 链表和双指针
	问题1：Remove Nth Node Form End of List
	给定一个链表，删除倒数第n个节点
	-如：1->2->3->4->5->NULL,n=2
	-返回:1->2->3->5
	class Solution {
	public:
		ListNode* removeNthFromEnd(ListNode* head, int n) {
			ListNode* dummyNode = new ListNode(0);
			dummyNode->next = head;
			
			ListNode* p = dummyNode;
			ListNode* q = dummyNode;
			for(int i = 0;i < n;i++)
				q = q->next;
			while(q->next)
			{
				p = p->next;
				q = q->next;
			}
			ListNode* delNode = p->next;
			p->next = delNode->next;
			delete delNode;
			
			ListNode* retNode = dummyNode->next;
			delete dummyNode;
			return retNode;
		}
	};
	问题2：Rotate List
	问题3：Reorder List
	问题4：Palindrome Linked
6. 	栈，队列，优先队列
6.1	栈的队列的基础应用
	问题1：Valid Parenttheses
	给定一个字符串，只包含(,[,{,),],},判断字符串中的括号匹配是否合法。
	--如"()"，"()[]{}"是合法的
	--如"(]"，"([)]"是非法的
	bool isValid(string s)
	{
		stack<char> stack;
		for(int i = 0;i < s.size(); i++)
		{
			if(s[i] == '(' || s[i] == '{' || s[i] == '[')
				stack.push(s[i]);
			else
			{
				if(stack.size() == 0)
					return false;
				char c = stack.top();
				stack.pop();
				
				char match;
				if(s[i] == ')')
					match = '(';
				else if(s[i] == ']')
					match = '[';
				else
				{
					assert(s[i] == '}');
					match = '{';
				}
				if(c != match)
					return false;
			}
		}
		if(stack.size() == 0)
			return false;
		return true;
	}
	问题2：Evaluate Reverse Polish Notation
	问题3：Simplify Path
6.2 栈和递归的紧密关系
	问题1：Binary Tree Preorder Traversal
	问题2：Binary Tree Inorder Traversal
	问题3：Binary Tree Postorder Traversal
	利用栈实现递归
6.3 运用栈模拟递归
	问题1：Binary Tree Preorder Traversal
	struct TreeNode{
		int val;
		TreeNode *left;
		TreeNode *right;
		TreeNode(int x):val(x),left(NULL),right(NULL){}
	};
	struct Command{
		string s;
		TreeNode* node;
		Command(string s,TreeNode* node):s(s),node(node){}
	};
	vector<int> preorderTraversal(TreeNode* root)
	{
		vector<int> res;
		if(root == NULL)
			return res;
		stack<Command> stack;
		stack.push(Command("go",root));
		while(!stack.empty()){
			Command command = satck.top();
			stack.pop();
			if(command.s == "print")
				res.push_back(command.node->val);
			else
			{
				assert(command.s == "go");
				if(command.node->right)
					stack.push(Command("go",command.node->right));
				if(command.node->left)
					stack.push(Command("go",command.node->left));
				stack.push(Command("print",command.node));
			}
		}
		return res;
	}
	问题2：Flatten Nested List Lterator
6.4	队列的典型应用
	问题1：Binary Tree Level Order Traversal
	对二叉树进行层序遍历
	vector<vector<int>> levelOrder(TreeNode* root)
	{
		vector<vector<int>> res;
		if(root == NULL)
			return res;
		queue< pair<TreeNode*,int> > q;
		q.push(make_pair(root,0));
		while(!q.empty())
		{
			TreeNode* node = q.front().first;
			int level = q.front().second;
			q.pop();
			
			if(level == res.size())
				res.push_back(vector<int>());
			res[level].push_back(node->val);
			if(node->left)
				q.push(make_pair(node->left,level+1));
			if(node->right)
				q.push(make_pair(node->right,level+1));
		}
	}
	问题2：Binary Tree Level Order TravelsalII
	问题3：Binary Tree Zigzag Level Order Traversal
	问题4：Binary Tree Right Side View
6.5	BFS和图的最短路径
	问题1：Perfect Squares
	给出一个正整数，寻找最少的完全平方数，使他们的和为n
	--完全平方数:1,4,9,16
	--12 = 4 + 4 + 4
	--13 = 4 + 9
6.6 优先队列
	优先队列的底层实现：堆
	使用优先队列解决算法问题
	C++ : priority_queue
	priority_queue<int> pq1:默认最大堆
	priority_queue<int,vector<int>,greater<int>> pq2：最小堆
	//自定义比较
	bool myCmp(int a, int b){
		return a%10 < b%10;
	}
	priority_queue<int,vector<int>,dunction<bool(int,int)>> pq3(myCmp);
6.7 优先队列相关的算法问题
	问题1：给定一个非空数组，返回前K个出现频率最高的元素。
	--如给定[1,1,1,2,2,3]
	--返回[1,2]
	--注意K的合法性问题
	思路1：扫描一遍统计频率；排序找到前K个出现频率最高的元素。O(nlogn)
	思路2：维护一个含有k个元素的优先队列。如果遍历到的元素比队列中的最小频率元素的频率高，
	则去除队列中最小频率的元素，将新元素入队。最终，队列中剩下的，就是前K个出现频率最高的元素。O(nlogk)
	vector<int> topKFrequent(vector<int>& nums,int k)
	{
		assert(k > 0);
		//统计每个元素出现的频率
		unordered_map<int,int> freq;
		for(int i = 0;i < nums.size();i++)
			freq[nums[i]]++;
		assert(k <= freq.size());
		//扫描freq，维护当前出现频率最高的k个元素(频率，元素)
		priority_queue< pair<int,int>,vector<pair<int,int>>, greater<pair<int,int>> > pq;
		for(unordered_map<int,int>::iterator iter = freq.begin();
			iter != freq.end(); iter++)
		{
			if(pq.size() == k)
			{
				if(iter->second > pq.top().first)
				{
					pq.pop();
					pq.push(make_pair(iter->second,iter->first));
				}
			}
			else 
				pq.push(make_pair(iter->second,iter->first));
		}
		vector<int> res;
		while(!pq.empty())
		{
			res.push_back(pq.top().second);
			pq.pop();
		}
		return res;
	}
	问题2：Merge k Sorted List
7.	二叉树和递归
7.1 二叉树天然的递归结构
	二叉树和递归
	问题1：Maximum Depth of binary Tree
	求一颗二叉树的最高深度
	从根节点到叶子节点的最高深度
	struct TreeNode{
		int val;
		TreeNode* left;
		TreeNode *right;
		TreeNode(int x) : val(x) ,left(NULL), right(NULL){}
	};
	int maxDepth(TreeNode* root)
	{
		if(root == NULL)
			return 0;
		int leftMaxDepth = maxDepth(root->left);
		int rightMaxDepth = maxDepth(root->right);
		return max(leftMaxDepth,rightMaxDepth) + 1;
	}
	问题2：Minimum Depth of Binary Tree
	从根节点到叶子节点的最短路径长度
7.2 一个简单的二叉树问题引发的血案
	问题1：Invert Binary Tree
	TreeNode* invertTree(TreeNode* root)
	{
		if(root == NULL)
			return NULL;
		TreeNode temp = root->left;
		root->left = root->right;
		root->right = temp;
		invertTree(root->left);
		invertTree(root->right);
		return root;
	}
	问题2：Samp Tree
	问题3：Symmetric Tree
	问题4：Count Complete Tree Nodes
	问题5：Balanced binary Tree
7.3 注意递归的终止条件
	问题1：Path Sum
	给出一颗二叉树以及一个数字sum，判断在这可二叉树上是否存在一条从根到叶子的路径，
	其路径上的所有节点和为sum
	bool hasPathSum(TreeNode* root, int sum)
	{
		if(root == NULL)
			return false;
		if(root->left == NULL && root->right == NULL)
			return sum == root->val;
		if(hasPathSum(root->left, sum-root->val))
			return true;
		if(hasPathSum(root->right,sum - root->val))
			return true;
		return false;
	}
	问题2：Sum of Left Leaves
7.4	定义递归问题
	问题1：Binary Tree Paths
	给定一颗二叉树，返回所有表示根节点到叶子节点路径的字符串。
		1
	  /	  \
	 2	   3
	  \
	   5
	-如上图结果为["1->2->5","1->3"]
	vector<string> binaryTreepaths(TreeNode* root)
	{
		vector<string> res;
		if(root == NULL)
			return res;
		if(root->left == NULL && root->right == NULL)
		{
			res.push_back(to_string(root->val));
			return res;
		}
		vector<string> leftString = binaryTreepaths(root->left);
		for(int i = 0;i < leftString.size();i++)
			res.push_back(to_string(root->val) + "->" leftString[i]);
		vector<string> rightString = binaryTreepaths(root->right);
		for(int i = 0;i < rightString.size();i++)
			res.push_back(to_string(root->val) + "->" rightString[i]);
		return res;
	}
	问题2：Path Sum II
	问题3：Sum Root to Leaf Numbers
7.5 更复杂的递归逻辑
	问题1：Path Sum III
	给出一颗二叉树以及一个数字sum，判断在这可二叉树上存在多少条路径，其路径上的所有节点和为sum
	int pathSum(TreeNode* root, int sum)
	{
		if(root == NULL)
			return 0;
		int res = findPath(root,sum);
		res += pathSum(root->left,sum);
		res += pathSum(root->right,sum);
		return res;
	}
	//在以node为根节点中，寻找包含node的路径，和为sum
	int findPath(TreeNode* node,int num)
	{
		if(node == NULL)
			return 0;
		int res = 0;
		if(node->val == num)
			res += 1;
		res += findPath(node->left,num-node->val);
		res += findPath(node->right,num-node->val);
		return res;
	}
7.6 二分搜索树中的问题
	问题1：Lowest Common Ancestor of a Binary Search Tree
	给定一颗二分搜索树和两个节点，寻找这两个节点的最近公共祖先。
	--如右图所示二分搜索树
	--2和8的最近公共祖先为6
	--2和4的最近公共祖先为2
	TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p,TreeNode* q)
	{
		assert( p != NULL && q != NULL);
		if(root == NULL)
			return NULL;
		if(p->val < root->val && q->val < root->val)
			return lowestCommonAncestor(root->left,p,q);
		if(p->val > root->val && q->val > root->val)
			return lowestCommonAncestor(root->right,p,q);
		return root;
	}
	问题2：Validate Binary Search Tree
	问题3：delete Node in a BST
	问题4：Convert Sorted Array to Binary Search Tree
	问题5：Kth Smallest Element in a BST
	问题6：Lowest Common Ancestor of a Binary Tree
8. 递归和回溯
8.1 树形问题
	问题1：Letter Combinations of a Phone Number
	给出一个数字字符串，返回这个数字字符串能表示的所有字母组合
	const string letterMap[10] = {
		" ",	//0
		"",		//1
		"abc",	//2
		"def",	//3
		"ghi",	//4
		"jkl",	//5
		"mno",	//6
		"pqrs",	//7
		"tuv",	//8
		"wxyz"	//9
	}
	vector<string> res;
	void findCombination(const string &digits, int index, const string &s)
	{
		if(index == digits.size())
		{
			res.push_back(s);
			return;
		}
		char c = digits[index];
		assert(c >= '0' && c <= '9' && c != '1');
		string letters = letterMap[c-'0'];
		for(int i = 0;i < letters.size();i++)
			findCombination(digits,index+1,s+letters[i]);
		return;
	}
	vector<string> letterCombinations(string digits)
	{
		if(digits == "")
			return res;
		findCombination(digits,0,"");
		return res;
	}
8.2 什么是回溯
	回溯法是暴力解法的一个主要实现手段，对于可能性随n变化的问题，如上题。
	问题1：Restore IP Addresses
	问题2：Palindrome Partitioning
8.3 回溯算法的应用
	排列问题
	问题1：Permutations
	给定一个整形数组，其中的每个元素都各不相同，返回这个元素所有排列的可能。
	-如对于[1,2,3]
	-返回[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
	
	vector<vector<int>> res;
	vector<bool> used;
	
	//p中保存一个有index个元素的排列
	//向这个排列的末尾添加第index+1个元素，获得一个有index+1个元素的排列
	void generatePermutation(const vector<int>& nums, int index, vector<int>& p)
	{
		if(index == nums.size())
		{
			res.push_back(p);
			return;
		}
		for(int i = 0; i < nums.size(); i++)
			if( !used[i] )
			{
				//将nums[i]添加在p中
				p.push_back(nums[i]);
				used[i] = true;
				generatePermutation(nums,index+1,p);
				p.pop_back();
				used[i] = false;
			}
		return;
	}
	vector<vector<int>> permute(vector<int>& nums)
	{
		res.clear();
		if(nums.size() == 0)
			return res;
		used = vector<bool>(nums.size(),false);
		vector<int> p;
		generatePermutation(nums,0,p);
		return res;
	}
	问题2：Permutations II
8.4	组合问题
	问题1：Combinations
	给出两个整数n和k，求在1...n这n个数字中选择出k个数字的所有组合
	-如n=4,k=2
	-结果为[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
	
	vector<vector<int>> res;
	
	//求解C(n,k),当前已经找到的组合存储在C中，需要从start开始搜索新的元素
	void generateCombinations(int n, int k, int start, vector<int> &c)
	{
		if(c.size() == k)
		{
			res.push_back(c);
			return;
		}
		for(int i = start; i <= n; i++)
		{
			c.push_back(i);
			generateCombinations(n,k,i+1,c);
			c.pop_back();
		}
		return;
	}
	vector<vector<int>> combine(int n, int k)
	{
		res.clear();
		if(n <= 0 || k <= 0 || k > n)
			return res;
		vector<int> c;
		generateCombinations(n,k,1,c);
		return res;
	}
8.5 回溯法解决组合问题的优化
	回溯法的剪枝
	vector<vector<int>> res;
	
	//求解C(n,k),当前已经找到的组合存储在C中，需要从start开始搜索新的元素
	void generateCombinations(int n, int k, int start, vector<int> &c)
	{
		if(c.size() == k)
		{
			res.push_back(c);
			return;
		}
		// 还有k-c.size()个空位，所以，[i...n]中至少要有k-c.size()个元素
		// i最多为n-(k-c.size()) + 1
		for(int i = start; i <= n-(k-c.size()) + 1; i++)
		{
			c.push_back(i);
			generateCombinations(n,k,i+1,c);
			c.pop_back();
		}
		return;
	}
	vector<vector<int>> combine(int n, int k)
	{
		res.clear();
		if(n <= 0 || k <= 0 || k > n)
			return res;
		vector<int> c;
		generateCombinations(n,k,1,c);
		return res;
	}
	问题2：Combination Sum
	问题3：Combination Sum II
	问题4：Combination Sum III
	问题5：Subsets
	问题6：Subsets II
	问题7：Binary Watch
8.6	二维平面上使用回溯法
	问题1：Word Search
	给定一个二维平面的字母和一个单词，看是否可以在这个二维平面上找到该单词。其中找到这个单词的
	规则是，从一个字母出发，可以横向或者纵向连接二维平面上的其他字母。同一个位置的字母只能使用一次。
	
	int d[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};
	
	//从Borad[startx][starty]开始，寻找word[index...word.size()]
	bool searchWord(const vector<vector<char>>& board,const string& word,int index,int startx,int starty)
	{
		if(index == word.size() - 1)
			return board[startx][starty] == word[index];
		if(board[startx][starty] == word[index])
		{
			//从startx，starty触发，向四个方向
			for(int i = 0;i < 4; i++)
		}
		return false;
	}
	bool exist(vector<vector<char>>& board,string word)
	{
		for(int i = 0; i < board.size(); i++)
			for(int j = 0;j < board[i].size(); j++)
				searchWord();
	}