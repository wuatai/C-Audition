一、排序算法
1.为什么要学习O(n^2)的排序算法
	基础，编码简单，易于实现，是一些简单情景的首选
	在一些特殊情况下，简单的排序算法更有效
	简单的排序算法思想衍生出复杂的排序算法
	作为子过程，改进更复杂的排序算法
1.1 选择排序 Selection Sort	O(n^2)
	基本思想，将数据分为有序和无序两部分，先找到最小的元素，和没排序部分的第一个位置交换位置
	然后从没排序的部分找到最小的，与第一个无序部分交换，则有序部分不断扩充，无序部分不断减少，
	直到无序部分没有数据，结束。
	代码：
	#include <iostream>
	#include <algorithm>
	using namespace std;
	template <typename T>
	void selectionSort(T arr[] , int n)
	{
		for(int i = 0; i < n; i++)
		{
			//寻找[i,n)区间里的最小值
			int minIndex = i;
			for(int j = i+1;j < n;j++)
			{
				if(arr[j] < arr[minIndex])
				{
					minIndex = j;
				}
			}
			swap(arr[i],arr[minIndex]);
		}
	}
	int main()
	{
		int a[10] = {10,9,8,7,6,5,4,3,2,1};
		selectionSort(a,10);
		for(int i = 0; i < 10; i++)
			cout << a[i] << endl;
			
		string c[4] = {"D","C","B","A"};
		selectionSort(c,4);
		for(int i = 0; i < 10; i++)
			cout << c[i] << endl;
			
		Student d[4] = { {"D",90}, {"C",30}, {"B",50}, {"A",80} };
		selectionSort(d,4);
		for(int i = 0; i < 10; i++)
			cout << d[i] << endl;
			
		return 0;
	}
	上面的程序只能对int数组排序，下面用模板来泛化
	struct Student
	{
		string name;
		int score;
		bool operator<(const Student &otherStudent)
		{
			return score < otherStudent.score;
		}
		friend ostream& operator<<(ostream &os,const Student &student)
		{
			os<<"Student: "<<student.name<<" "<<student.score<<endl;
			return os;
		}
	};
	
	随机生成算法测试用例
	#include <ctime>
	#include <iostream>
	#include <cassert>
	using namespace std;
	namespace SortTestHelper
	{
		//生成n个在RangeL和RangeR之间的元素的随机数组
		int* generateRandomArray(int n,int rangeL, rangeR)
		{
			assert(rangeL <= rangeR);
			int *arr = new int[n];
			srand(time(NULL));
			for(int i = 0;i < n;i++)
			{
				//生成随机数
				arr[i] = rand() % (rangeR - rangeL + 1) + rangeL;
			}
			return arr;
		}
		
		template<typename T>
		void printArray(T arr[], int n)
		{
			for(int i = 0;i < n;i++)
				cout << arr[i] << " ";
			cout << endl;
			return;
		}
		
		int* copyIntArray(int a[],int n)
		{
			int* arr = new int[n];
			copy(a,a+n,arr);
			return arr;
		}
	}
	
	int n = 10000;
	int *arr = SortTestHelper::generateRandomArray(n,0,n);
	selectionSort(arr,n);
	SortTestHelper::printArray(arr,n);
	delete[] arr;
	
	测试算法的性能
	namespace SortTestHelper
	{
		//计算程序运行时间
		template<tyepname T>
		void testSort(string sortName,void(*sort)(T[],int),T arr[],int n)
		{
			clock_t startTime = clock();
			sort(arr,n);
			clock_t endTime = clock();
			assert(isSorted(arr,n));
			cout << sortName<<" :" << double(endTime - startTime) / CLOCKS_PRE_SEC << "s" << endl;
			return;
		}
		//测试排序是否成功
		template<typename T>
		bool isSorted(T arr[], int n)
		{
			for(int i = 0; i < n - 1; i++)
				if(arr[i] > arr[i + 1])
					return false;
			return true;
		}
	}
	
	int main()
	{
		int n = 10000;
		int *arr = SortTestHelper::generateRandomArray(n,0,n);
		SortTestHelper::testSort("Selection Sort",selectionSort,arr,n);
	}
	
1.2 插入排序
	算法思想：一个序列分无序和有序，初始的时候序列第一个是有序的，后面的都是无序的
	从第二个开始，将其分别和有序的数据对比，交换，直到插入到了合适的位置。（扑克牌）
	
	代码：
	#include <iostream>
	#include <algorithm>
	#include "SortTestHelper.h"
	#include "SelectionSort.h"
	
	using namespace std;
	
	template<typename T>
	void insertionSort(T arr[], int n)
	{
		for(int i = 1; i < n; i++)
		{
			//寻找第i个元素的插入位置
			for(int j = i; j > 0; j--)
			{
				if(arr[j] < arr[j-1])
				{
					swap(arr[j],arr[j-1]);
				}
				else
				{
					break;
				}
			}
		}
	}
	
	简洁版：
	
	template<typename T>
	void insertionSort(T arr[], int n)
	{
		for(int i = 1; i < n; i++)
		{
			//寻找第i个元素的插入位置
			for(int j = i; j > 0 && arr[j] < arr[j-1]; j--)
			{
				swap(arr[j],arr[j-1]);
			}
		}
	}
	
	测试：
	int main()
	{
		int n = 10000；
		int *arr = SortTestHelper::generateRandomArray(n,0,n);
		int *arr2 = SortTestHelper::copy(arr,n);
		
		SortTestHelper:testSort("Insertion Sort",insertionSort,arr,n);
		a=SortTestHelper::testSort("Selection Sort",selectionSort,arr2,n);
		
		delete[] arr;
		delete[] arr2;
		return 0;
	}
	
	改进版插入排序
	思想，先把无序的元素保存下来，用赋值替换swap
	template<typename T>
	void insertionSort(T arr[], int n)
	{
		T e = arr[i];
		for(int i = 1; i < n; i++)
		{
			//寻找第i个元素的插入位置
			for(int j = i; j > 0 && arr[j-1] > e; j--)
			{
				arr[j]=arr[j-1];
			}
			arr[j] = e;
		}
	}
小结：
O(n^2)的排序算法：
选择排序，插入排序，冒泡排序，希尔排序（O(n^1.3-2)）
对于近乎有序的数组，插入排序特别快，有可能比nlogn还快。

下面介绍O(n*logn)的排序算法
1.3 归并排序
	算法思想：将序列分成2部分，分别排序，然后合并。
	合并的时候需要另外一个数组，和三个指针，分别指向新数组，左边有序数组和右边有序数组。
	
	代码：
	//合并,将arr[l...mid]和arr[mid+1...r]两部分进行归并
	template<typename T>
	void __merge(T arr[], int l,int mid, int r)
	{
		T aux[r-l+1];
		for(int i = l;i <= r;i++)
		{
			aux[i-l] = arr[i];
		}
		int i = l,j=mid + 1;
		for(int k = l;k <= r;k++)
		{
			//先考虑一端已经遍历完的情况
			if(i > mid)
			{
				arr[k] = aux[j-l];
				j++;
			}
			else if(j > r)
			{
				arr[k] = aux[i-l];
				i++;
			}
			//再考虑两端都没有遍历完的情况
			else if(aux[i-l] < aux[j-l])
			{
				arr[k] = aux[i-l];
				i++;
			}
			else
			{
				arr[k] = aux[j-l];
				j++;
			}
		}
	}
	
	// 递归使用归并排序，对arr[l...r]的范围进行排序
	template<typename T> 
	void __mergeSort(T arr[],int l,int r)
	{
		//递归停止条件（至少要有两个元素）
		if(l >= r)
			return;
		int mid = (l + r) / 2;
		__mergeSort(arr,l,mid);
		__mergeSort(arr,mid+1,r);
		__merge(arr,l,mid,r);
	}
	
	template<typename T>
	void mergeSort(T arr[],int n)
	{
		__mergeSort(arr,0,n-1);
	}
	
	归并排序需要利用额外的辅助空间来存储，利用的是分而治之，可以将N规模的问题变成logN
	规模的问题，一个问题是N复杂度，所以归并排序是NlogN复杂度。
	
	归并排序优化：
	template<typename T> 
	void __mergeSort(T arr[],int l,int r)
	{
		//递归停止条件（至少要有两个元素）
		if(l >= r)
			return;
		int mid = (l + r) / 2;
		__mergeSort(arr,l,mid);
		__mergeSort(arr,mid+1,r);
		//如果左边最后一个比右边第一个要小，则不归并。
		if(arr[mid] > arr[mid + 1])
			__merge(arr,l,mid,r);
	}
	
	上面介绍的都是递归，下面用迭代来实现
	template<typename T>
	void mergeSortBU(T arr[],int n)
	{
		for(int sz = 1;sz <= n;sz += sz)
		{
			for(int i = 0; i+sz<n;i += sz)
			{
				//对arr[i...i+sz-1]和arr[i+sz...i+sz+sz-1]进行归并
				__merge(arr,i,i+sz-1,min(i+sz+sz-1,n-1));
			}
		}
	}
	
1.4 快速排序
	算法思想：以某个元素为基点，处理一遍后左边的数都小于该元素，右边的数都大于该元素
	然后对左边和右边的分别进行上述过程。
	
	//对arr[l...r]部分进行partition操作
	//返回p，使得arr[l...p-1] < arr[p];arr[p+1...r] > arr[p]
	template<typename T>
	int __partition(T arr[], int l, int r)
	{
		swap(arr[rand()%(r-l+1)+l]); //随机化优化
		T v = arr[l];
		int j = l;
		for(int i = l + 1;i <= r; i++)
		{
			if(arr[i] < v)
			{
				swap(arr[j+1],arr[i]);
				j++;
			}
		}
		swap(arr[l],arr[j]);
		return j;
	}
	
	template<tyepname T>
	void __quickSort(T arr[], int l, int r)
	{
		if(l >= r)
		{
			return;
		}
		int p = __partition(arr,l,r);
		__quickSort(arr,l,p-1);
		__quickSort(arr,p+1,r);
	}
	
	
	template<tyepname>
	void quickSort(T arr[], int n)
	{
		srand(time(NULL));	//随机化优化
		__quickSort(arr, 0 ,n-1);
	}
	
	双路快速排序partition
	//对arr[l...r]部分进行partition操作
	//返回p，使得arr[l...p-1] < arr[p];arr[p+1...r] > arr[p]
	template<typename T>
	int __partition2(T arr[], int l, int r)
	{
		swap( arr[l], arr[rand()%(r-l+1)+l] );
		T v = arr[l];
		
		//arr[l+1...i) <= v;arr(j...r] >= v
		int i=l+1 , j=r;
		while(true)
		{
			while(i <= r && arr[i] < v) i++;
			while(j<=l+1 && arr[j] > v) j--;
			if(i > j) break;
			swap(arr[i],arr[j]);
			i++;
			j--;
		}
		swap(arr[l],arr[j]);
		return j;
	}
	
	//三路快速排序
	template<typename T>
	void __quickSort3Ways(T arr[], int l, int r)
	{
		if(r - l <= 15)
		{
			insertionSort(arr,l,r);
			return;
		}
		//partition
		swap(arr[l],arr[rand()%(r-l+1)+l]);
		T v = arr[l];
		
		int lt = l;//arr[l+1...lt] < v
		int gt = r + 1;//arr[gt...r] > v
		int i = l + 1;// arr[lt+1...i) == v
		while(i < gt)
		{
			if(arr[i] < v)
			{
				swap(arr[i],arr[lt+1]);
				lt++;
				i++;
			}
			else if(arr[i] > v)
			{
				swap(arr[i],arr[gt-1]);
				gt--;
			}
			else
			{
				i++;
			}
		}
		swap(arr[l],arr[lt]);
		__quickSort3Ways(arr,l,lt-1);
		__quickSort3Ways(arr,gt,r);
		
	}
	
	快速排序局限性：
	对于近乎有序的数组，快速排序生成的递归树平衡度很差，分成的两部分一方很小，一方很大。
	完全有序，退化成O(n^2)
	
	对于具有大量重复数据的序列，平衡度很差，分成两部分一方很少，一方很多（因为==的数据太多了）。
	
	优化：
	随机化快速排序（解决近乎有序的缺陷）
	双路快速排序（解决具有大量重复数据）
	三路快速排序（更加快速地解决大量重复数据）
	
	小结：
	归并排序和快速排序都利用了分治的思想
	
	归并排序和快速排序的衍生问题
	1.归并排序求逆序对的个数
	2.快速排序求数组第n大元素（O(2n) n + n/2 + n/4 + n/8 + ... + 1）
	
2.堆
2.1 堆排序
堆是优先队列的实现数据结构，主要操作，入队（logN），出队(logN)（取出优先级醉倒的元素）
2.2 堆的基本实现（二叉堆Binary heap）
条件：堆总是一颗完全二叉树（最后一层的节点必须集中在左侧）
	  堆中某个节点的值总是不大于其父节点的值（最大堆）
用数组来存储二叉堆（另根节点序号为1，父节点的左右节点是2n和2n+1）
则：parent(i) = i/2;
	left child (i) = 2*i;
	right child (i) = 2*i + 1;

代码：
	#include <iostream>
	#include <alogrithm>
	#include <string>
	#include <ctime>
	#include <cmath>
	#include <cassert>
	using namespace std;
	template<typename Item>
	class MaxHeap
	{
	private:
		Item* data;
		int count;
		int capacity;
		//堆重构
		void shiftUp(int k)
		{
			while( k > 1 && data[k/2] < data[k])
			{
				swap(data[k/2],data[k]);
				k /= 2;
			}
		}
	public:
		MaxHeap(int capacity)
		{
			//从索引1开始的，所以+1
			data = new Item[capacity + 1];
			count = 0;
			this->capacity = capacity;
		}
		int size()
		{
			return count;
		}
		bool isEmpty()
		{
			return count == 0; 
		}
		~MaxHeap()
		{
			delete[] data;
		}
		
		void insert(Item  item)
		{
			assert(count + 1 <= capacity);
			data[count+1] = item;
			count++;
			shiftUp(count);
		}
	};
	int mian()
	{
		MaxHeap<int> maxheap = MaxHeap<int>(100);
		
		
		return 0;
	}