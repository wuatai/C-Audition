1.从排序数组中删除重复项
class Solution{
public:
	int removeDuplicates(vector<int>& nums){
		if(nums.empty())
			return 0;
		vector<int>::iterator step = nums.begin();
		for(vector<int>::iterator it = nums.begin(); it!=nums.end(); it++)
		{
			if(*step != *it)
			{
				step++;
				*step = *it;
			}
		}
		return step - nums.begin() + 1;
	}
};

2.买卖股票的最佳时机
示例
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.empty())
            return 0;
        vector<int>::iterator step1 = prices.begin();
        vector<int>::iterator step2 = prices.begin();
        int maxStep = 0;
        int allGet = 0;
        for(vector<int>::iterator it = prices.begin(); it != prices.end(); it++)
        {
            if(*it > *step2)
            {
                maxStep = (*it - *step1);    
                step2 = it;
            }
            else
            {
                allGet += maxStep;
                maxStep = 0;
                step1 = it;
                step2 = it;
            }
            if(it == prices.end() - 1)
            {
                allGet += maxStep;                
            }
        }
        return allGet;
    }
};

3.旋转数组
示例
输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int length = nums.size();
        for(int i = 0;i < k;i++)
        {
            int temp = nums[length-1];
            for(int j =length-1;j > 0;j--)
            {
                nums[j] = nums[j-1];
            }
            nums[0] = temp;
        }
    }
};

4.存在重复
输入: [1,2,3,1]
输出: true
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        set<int> sNums(nums.begin(),nums.end());
        if(sNums.size() != nums.size())
            return true;
        return false;
    }
};

5.只出现一次的数字
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
输入: [4,1,2,1,2]
输出: 4

class Solution {
public:
    int singleNumber(vector<int>& nums) 
    {
        map<int,int> mNums;
        for(vector<int>::iterator it = nums.begin(); it != nums.end(); it++)
        {
            mNums[*it] += 1;
        }
        for(const auto itM : mNums)
        {
            if(itM.second == 1)
                return itM.first;
        }
    }
};

亦或法：相同的数字经过异或运算后结果为0，除单独出现一次的数字外，其他数字都是出现两次的，那么这些数字经过异或运算后结果一定是0。
而任何数字与0进行异或运算都是该数字本身。所以对数组所有元素进行异或运算，运算结果就是题目的答案。
class Solution {
public:
    int singleNumber(vector<int>& nums) 
    {
		int num = 0;
        for(int i = 0;i < nums.size();i++)
		{
			num = num ^ nums[i];
		}
		return num;
    }
};

6.加1
给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。
输入: [4,3,2,1]
输出: [4,3,2,2]
解释: 输入数组表示数字 4321。
class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        int length = digits.size();
        for(int i = length-1;i >= 0;i--)
        {
            if(digits[i] == 9)
                digits[i] = 0;
            else
            {
                digits[i] += 1;
                return digits;
            }
        }
        if(digits.front() == 0)
            digits.insert(digits.begin(),1);
        return digits;
    }
};

7.移动零
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int k = 0;
        int length = nums.size();
        for(int i = 0;i < length; i++)
        {
            if(nums[i] != 0)
            {
                nums[k++] = nums[i];
            }
        }
        while(k < length)
        {
            nums[k++] = 0;
        }
    }
};