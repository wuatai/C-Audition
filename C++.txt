1.strcpy函数的编写？（memcpy函数的编写）(考点：内存重叠的情况)
	#include <assert.h>
	char * strcpy(char* dest,const char* source)
	{
		assert(dest != NULL && source != NULL);
		if(NULL == dest || NULL == source)
		{
			return NULL;
		}
		char * p = dest;
		size_t len = strlen(source);
		if(dest >= src && dest <= source + len)
		{
			p = p + len - 1;
			source = source + len - 1;
			for(size_t i = 0; i < strlen(source); i++)
			{
				*p-- = *source--;
			}
		}
		else
		{
			while(source != '\0')
			{
				*p++ = *source++;
			}
		}
		return dest;
	}
	
	//防止内存重叠需要从后往前复制
	void* memcpy(void* dest,const void* source,size_t count)
	{
		char *dp = (char*)dest;
		char *sp = (char*)source;
		if(NULL == dest || NULL == source)
		{
			return NULL;
		}
		if(dest > source && dest < source + count) //从后往前复制
		{
			dp = dp + count - 1;
			sp = sp + count - 1;
			while(count--)
			{
				*dp-- = *sp--;
			}
		}
		else
		{
			for(size_t i = 0; i < count ; i++)
			{
				*dp++ = *sp++;
			}
		}
		return dest;
	}
2.c++中四种类型转换机制
	例子：A是AA的基类
	static_cast<type>()： 1）完成基础数据类型，2）同一个继承体系中类型的转换 3）任意类型与空指针类型void*之间的转换。
		A a = static_cast<A>(aa);	//编译通过，子类对象可以变成父类对象，但是内存会被剪切
		AA aa = static_cast<AA>(a);	//编译不过,父类对象不能变成子类对象
		AA *paa = static_cast<A*>(paa);	//编译通过，父类指针指向子类对象，正常的多态
		AA *paa = static_cast<AA*>(pa);	//编译通过，子类指针指向了父类对象，访问子类成员时不可预料
	dynamic_cast<type>()：主要用在继承体系中的安全向下转型。它能安全地将指向基类的指针转型为指向子类的指针或引用，并获知转型动作成功是否。转型失败会返回null（转型对象为指针时）或抛出异常（转型对象为引用时）。 只有在基类带有虚函数的情况下才允许将基类转换为子类
		（dynamic_cast类型必须是指针或者引用）
		AA* paa = dynamic_cast<AA*>(pa);	//编译通过，但是返回NULL，子类指针指向父类对象
		A* pa = dynamic_cast<A*>(paa);		//编译通过，且转换成功
		A& pa = dynamic_cast<A&>(*paa);		//编译通过，子类对象引用指向父类对象，数据会被截取
		AA& paa = dynamic_cast<AA&>(*pa);	//编译通过，但是引发了异常（所谓的安全转型）
	const_cast<type>()：增加或删除const属性。（const_cast类型必须是指针或者引用）
		const A *pa = new A();
		A& a = const_cast<A&>(*pa);
		a.a = 2;						//编译通过，可通过A来修改
	reinterpret_cast<type>()
3.继承机制中对象之间是如何转换的
4.继承机制中，引用和指针之间是如何转换的
	基类——>派生类：用dynamic_cast转换，首先检查基类指针（引用）是否真正指向一个派生类对象，然后再做相应处理，对指针进行dynamic_cast，成功返回派生类对象，失败返回空指针，对引用进行dynamic_cast，成功返回派生类对象，失败抛出一个异常。 
	派生类——>基类：可以用dynamic_cast或者直接进行类型转换（直接赋值）。
5.虚函数，虚函数表里面内存如何分配的
	虚函数表中包含类的虚函数，通过虚表指针访问，虚表指针在构造对象时生成。
6.STL中迭代器的作用，有指针为何还要迭代器
	通过迭代器能访问STL容器的内容，隐藏容器内部的实现，还能为算法和容器之间提供桥梁，使得算法和数据结构能够分开
7.STL中map与unordered_map
	map是STL的一个关联容器，内部自建一个红黑树，所以map内部所有的数据都是有序的，且map的查询、插入、删除操作复杂度都是O(logN)
	unorder_map底层是hash表，和map类似，可以通过key快速所引导value，不同的是unordered_map不会根据key的大小进行排序，存储时根据key的hash值判断元素是否相同，即unordered_map是无序的。
8.inline有什么用，STL用的多吗？
	inline节省开销，直接在编译期间将代码展开，又不会像宏一样导致语义错误，inline只是给编译器的建议，如果函数复杂，编译器会忽略。
9.vector扩容，map用的什么实现？
	vector如果容量不够，申请2倍（空间和时间的权衡）当前空间，拷贝旧空间到新内存，销毁旧空间。
	map用红黑树实现，查找存取时间复杂度logN
11.static用法
	1.全局静态变量：静态存储区，在整个程序运行期间一直存在，在声明他的文件之外是不可见的。
	2.局部静态变量：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变。
	3.静态函数：只是在声明他的文件当中可见，不能被其他文件所用。
	4.类的静态成员：属于该类的所有成员共有。
	5.类的静态成员函数：类的静态函数是该类的范畴内的全局函数，不能访问类的私有成员，只能访问类的静态成员，不需要类的实例即可调用。
12.const用法
	1.修饰成员变量 ：如果为指针，只有一个const，如果const位于*左侧，表示指针所指数据是常量，不能通过解引用修改该数据；
					只有一个const，如果const位于*右侧，表示指针本身是常量，不能指向其他内存地址；
					两个const，*左右各一个，表示指针和指针所指数据都不能修改。
	2.修饰函数参数：与变量一样
	3.修饰成员函数：const修饰的成员函数不能修改任何的成员变量
					const成员函数不能调用非const成员函数
	4.修饰函数返回值：返回值也必须赋给const data,non-const pointer
13.多态，虚函数，虚函数表，重写和重载区别
	多态：通过继承同一个基类，产生了相关的不同的派生类，与基类中同名的成员函数在不同的派生类中会有不同的实现，也就是说：一个接口、多种方法。
	虚函数：虚函数的作用是允许在派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类中的同名函数。
	虚函数表：用来访问虚函数，虚函数是存放在虚函数表中的。
	重载：是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。
	隐藏：是指派生类的函数屏蔽了与其同名的基类函数，注意只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。
	重写(覆盖)：是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。
15.c++11一些特性
16.手写C++实现一个STL里面的功能
17.vital关键字
18.为什么要用虚析构函数，什么是多态
19.const vector<int> 和vector <const int>的区别
20.new,delete和malloc，free的区别
21.struct和union的区别，struct如果里面存了double，int，short请问这个struct有几个字节，怎么存储的
22.C++相比C有哪三大特性？（多态，继承，封装）说说多态怎么实现的？什么时候需要用到虚析构函数？
23.如何禁止自动生成拷贝构造函数？
24.虚函数的内存结构，那菱形继承的虚函数内存结构呢
25.基类的析构函数为什么需要是虚函数
	答：new出来的是子类son的对象，采用一个父类father的指针来接收，故在析构的时候，编译器因为只知道这个指针是父类的，
	所以只将父类部分的内存析构了，而不会去析构子类的内存，就造成了内存泄露。基类析构函数定义为虚拟函数的时候，在子
	类的对象的首地址开始会有一块基类的虚函数表拷贝，在析构子类对象的时候会删除此虚函数表，此时会调用基类的析构函数，
	所以此时内存是安全的。
26.构造函数可以是虚函数吗？（编译不通过）
	答：虚函数的执行依赖于虚函数表。而虚函数表在构造函数中进行初始化工作，即初始化vptr，让他指向正确的虚函数表。
	而在构造对象期间，虚函数表还没有被初始化，将无法进行。
27.成员函数可以调用delete this吗？为什么？
28.四种类型转换？static_cast向上向下转换时的会出现什么问题。dynamic_cast失败的话会怎样。
29.为何static成员函数不能为virtual？（编译不通过）
	答：虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，因为它是
	类的一个成员，并且vptr指向保存虚函数地址的vtable.对于静态成员函数，它没有this指针，所以无法访问vptr. 这就是为何
	static函数不能为virtual.
	虚函数的调用关系：this -> vptr -> vtable ->virtual function
30.内联函数可以是虚函数吗？（编译能通过）
	答：inline是在编译器将函数类容替换到函数调用处，是静态编译的。而虚函数是动态调用的，在编译器并不知道需要调用的是
	父类还是子类的虚函数，所以不能够inline声明展开，所以编译器会忽略。
31.正确区分重载、重写和隐藏
	答：注意三个概念的适用范围：处在同一个类中的函数才会出现重载。处在父类和子类中的函数才会出现重写和隐藏。
	重载：同一类中，函数名相同，但参数列表不同。
	重写：父子类中，函数名相同，参数列表相同，且有virtual修饰。
	隐藏：父子类中，函数名相同，参数列表相同，但没有virtual修饰；函数名相同，参数列表不同，无论有无virtual修饰都是隐藏。
32.如何定义一个只能在栈上或者堆上生成对象的类？
33.sizeof(类)，如何计算类的大小？
34.sizeof(结构体)，如何计算结构体的大小？
35.结构体和类有什么区别？
36.extern“C”有什么作用？原理是什么？
37.const修饰的变量和#define有什么区别？
38.static有什么作用？如何改变变量的生命周期和作用域？
39.volitale什么作用？
40.new 和malloc有什么不一样？
41.指针和引用的区别？
42.STL容器有哪些？
43.vector内部数据结构是什？List/Map/Queue
44.STL，vector和List有什么不一样？map是用什么数据结构实现的？
45.面向对象有哪些特点？如何体现？
46.面向对象的设计原则有哪些？
47.如何检查内存泄漏？
48.从源代码到可执行二进制文件，要经过哪些过程？
49.C++中不能重载的运算符：“?:”、“.”、“::”、“sizeof”和”.*”
50.各个容器的内部实现数据结构
51.什么情况会导致栈溢出，内存泄漏