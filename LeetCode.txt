第一章.编程技巧
1.1在判断两个浮点数a和b是否相等时，不要用a==b，应该判断二者之差的绝对值fabs(a-b)是否小于某个阈值，例如1e-9.
1.2判断一个整数是否为奇数的时候，用x%2 != 0，不要用x%2 == 1，因为x可能为负数，负数奇数%2=负值
1.3用char的值做数组下标的时候，要先强制转换成unsigned char，因为char有可能是负数。
1.4vector和string优先于动态分配的数组。
1.5vector使用 reserve 来避免不必要的重新分配。
第二章。线性表
这类题目考察线性表的操作，例如数组，单链表，双向链表等
2.1.1 去除有序数组的重复数值
	输入 A=[1,1,2]
	输出 return 2,并且此时A=[1,2]
	解题1,时间复杂度O(n),空间(O(1))
	class Solution
	{
	public:
		int removeDuplicates(vector<int>& nums)
		{
			if(nums.empty()) return 0;
			int index = 0;
			for(int i = 1;i < nums.size();i++)
			{
				if(nums[index] != nums[i])
					nums[++index] = nums[i];
			}
		}
	};
	解题2，使用stl，时间复杂度O(n),空间(O(1))
	class Solution
	{
	public:
		int removeDuplicates(vector<int>& nums)
		{
			//std::unique返回两个迭代器之间的元素去重之后的所有不同元素的下一个位置的迭代器
			return distance(nums.begin(),unique(nums.begin(),nums.end()));
		}
	};
2.1.3 在旋转有序数组中查找元素
	分析：由于有序数组的查找一般采用二分查找，该题难度在于左右边界的确定
	You are given a target value to search. If found in the array return its index, otherwise return -1.
	You may assume no duplicate exists in the array
	代码：时间复杂度O(logn)，空间复杂度O(1)
	class Solution
	{
	public:
		int search(const vector<int>& nums, int target)
		{
			int first = 0,last = nums.size();
			while(first != last)
			{
				const int mid = first + (last-first)/2;
				if(nums[mid] == target)
					return mid;
				if(nums[first] < nums[mid]){
					if(nums[first] < target && target < nums[mid])
						last = mid;
					else
						first = mid + 1;
				}
				else{
					if(nums[mid] < target && target < nums[last])
						first = mid + 1;
					else
						last = mid;
				}
			}
			return -1;
		}
	};
2.1.6  Longest Consecutive Sequence 求最长连续序列
	Given an unsorted array of integers, find the length of the longest consecutive elements sequence.
	For example, Given [100, 4, 200, 1, 3, 2], The longest consecutive elements sequence is [1,2, 3, 4]. 
	Return its length: 4.
	Your algorithm should run in O(n) complexity
	
	分析：如果允许O(nlogn)的复杂度，name可以先排序，可是题目要求O(n)
	由于序列是无序的，有要求O(n)，首先要想到用哈希表
	用一个哈希表unordered_map<int,bool> used记录每个元素是否使用，对每个元素，以钙元素为中心，往左右扩张，直到
	不连续为止，记录下最长的长度。
	
	class Solution
	{
	public:
		int longestConsecutive(const vector<int> &nums)
		{
			unordered_map<int,bool> used;
			for(auto i : nums)
				used[i] = false;
			int longest = 0;
			for (auto i : nums)
			{
				if(used[i]) continue;
				int length = 1;
				used[i] = true;
				for(int j = i + 1; used.find(j) != used.end(); j++)
				{
					used[j] = true;
					++length;
				}
				for(int j = i - 1;used.find(j) != used.end();j--)
				{
					used[j] = true;
					++length;
				}
				longest = max(longest,length);
			}
			return longest;
		}
	};
	
2.1.7 两数之和Two Sum
	Given an array of integers, find two numbers such that they add up to a specific target number
	You may assume that each input would have exactly one solution.
	Input: numbers={2, 7, 11, 15}, target=9
	Output: index1=1, index2=2
	
	分析：方法1：暴力，复杂度O(n^2)
		  方法2：hash，哈希表，存储每个数对应的下标，判断target-当前 是否在hash表中，复杂度O(n)
	class Solution
	{
	public:
		vector<int> twoSum(vector<int> &nums, int target)
		{
			unordered_map<int,int> mapping;
			vector<int> result;
			for(int i = 0;i < nums.size();i++)
			{
				mapping[nums[i]] = i;
			}
			for(int i = 0;i < nums.size(); i++)
			{
				const int gap = target - nums[i];
				if(mapping.find(gap) != mapping.end() && mapping[gap] > i)
				{
					result.push_back(i+1);
					result.push_back(mapping[gap] + 1);
					break;
				}
			}
			return result;
		}
	};